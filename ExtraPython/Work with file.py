# =========================================================
#       Работа с файлами (file)
# =========================================================
"""
    Функция open
* открывает файл в указанном режиме
* f = open('my.txt', 'w')
* file — имя файла
* mode — режим
* encoding — кодировка
"""
"""
    Режимы открытия mode
* r — чтение
* w — запись, если файла нет, создается новый
* x — запись, если файла нет, ошибка
* a — дозапись
* b — двоичный режим
* + — открытие на чтение и запись
"""
# Если такого файла нет , то он создается в корне папки, если есть 
# то файл перезапишется 
# f = open('test_file.txt','w')
# Тут мы считываем файл 
# f = open('test_file.txt','r')

# f = open('test_file.txt','w')
# f.write('Hello\n')
# f.write('World\n')
# f.writelines(['Hello\n','Python\n'])
"""
    Чтение из файла
* read — чтение всего файла
* for line in f: — чтение файла построчно
* readlines — чтение файла в список строк
"""
# f = open('test_file.txt','r')
# print(f.read())
# for line in f:
    # print(line.replace('\n',''))# тут мы меняем перенос строки, чтобы в консоли не было пробела при выводе
# читает все строки
# print(f.readlines())
"""
    Закрытие файла
* После работы с файлом его необходимо закрывать.
* Открытые файлы тратят ресурсы системы.
* f.close().
* Если до close произойдет исключительная ситуация, файл не будет закрыт.
* Удобным вместо close() является использование with.
"""
# f = open('test_file.txt','r')
# print(f.readlines())
# f.close()

with open('test_file.txt','r') as f:
    print(f.readlines())
# c with не требует закрытие файла 
# =========================================================
# Строки, байты, кодировки 
# =========================================================
"""
    Типы строк в Python
* str — обычные строки
* bytes — строки байт
* bytearray — изменяемая строка байт
"""
# создание обычной строки 
s = 'Hello world'
print(type(s))
# создание строки байт ( ставим b перед кавычками) 
sb = b'Hello bytes'
print(type(sb))
print(sb)

# Индекс в обычной строке 
print(s[1])
# Индекс в строке байт
print(sb[1])
# перебор строки байт в цикле
for item in sb:
    print(item)
# В результате будут не символы а их закодированные представления
"""
    Основные кодировки
* ascii — американские символы.
* latin-1 — европейские символы.
* utf-8 — универсальная кодировка для большинства языков.
* Чем универсальнее кодировка, тем больше байт требуется для кодирования одного символа.
"""
# --------Кодирование строки --------
s = 'Hello world Мир'
sb = s.encode('utf-8')
print(sb)
# ---Декодирование строки(перевод байт в строку)---
"""
* sb.decode('utf-8').
* Указываем кодировку, которой мы кодировали строку.
"""
s =sb.decode('utf-8')
print(s)

# =========================================================
#  Модуль - pickle
# =========================================================
"""
    Сериализация
* Процесс преобразования объекта в поток байтов для сохранения или передачи в память, 
базу данных или файл.
* Обратный процесс — десериализация.
    Применение сериализации
* сохранение объекта в файл
* сохранение объекта в базу данных
* передача объекта по сети
* ...
-----------------------------
    Способы записи объекта в файл
* ручной (создание велосипеда)
* универсальный pickle
"""
'''
    Ручной способ
* {'name': 'Max', 'phones': [123, 345]}
* Как перевести такой объект (dict) в байты для сохранения в файл?
* Придумать способ приведения объекта к более простым.
* Придумать свой формат хранения.
'''
person = {'name': 'Max', 'phones': [123, 345]}
# откроем файл 
with open ('person.dat','wb') as f:
    # например запишем объект в файл построчно
    # сначала возьмем имя 
    name = person['name']
    # добавим перенос строки переведем в байты и запишем 
    f.write(f'{name}\n'.encode('utf-8'))
    # получим телефоны 
    phones = person['phones']
    # запишем 1 телефон в новую строку
    for phone in phones:
        f.write(f'{phone}\n'.encode('utf-8'))
print('объект записан')
'''
    Ручной способ (Недостатки)
* Не универсальный.
* При небольшом изменении объекта изменится весь алгоритм.
* Надо помнить, как мы делали сохранение, чтобы потом прочитать.
* Трудоемкий.
'''
# _________________________________________________________
'''
    Модуль pickle
* Сохраняет сложные объекты в файл. 
* Преобразует сложные объекты в байты.
* Встроен в Python.
-----------------------------
    pickle. Основные функции
* dump — сохранение объекта в файл 
* dumps — преобразование объекта в байты
* load — загрузка объекта из файла
* loads — загрузка объекта из набора байт
'''
import pickle
person = {'name': 'Max', 'phones': [123, 345]}
# открываем файлы
with open ('person.dat','wb') as f:
    # сразу пишем объект целиком с помощью pickle
    pickle.dump(person,f)

print('Объект записан')
# чтение из файла
# открываем файлы
with open ('person.dat','rb') as f:
    # сразу читаем объект из файла целиком с помощью pickle
    person = pickle.load(f)

print(person)
# =========================================================
#   Модуль - json
# =========================================================
'''
    Формат json
* JavaScript Object Notation.
* Текстовый формат обмена данными, основанный на JavaScript.
* Аналогичен набору словарей, списков, простых типов данных в Python.
* Является просто текстом (строкой)
-----------------------------
    Применение
* хранение данных
* передача данных
* чаще всего используется в web-разработке для передачи данных по протоколу http
    json в Python
* Основные структуры Python схожи с форматом.
* Требуется только преобразование в строку и обратно.
* Этим занимается модуль json.
* import json.
-----------------------------
    json. Основные функции
* dump — сохранение объекта в формате json в файл 
* dumps — преобразование объекта в json (в текст)
* load — загрузка объекта из файла
* loads — загрузка объекта из формата json (строки)
'''
import json
friends = [
    {'name':'Max','age':23,'phones':[123,345]},
    {'name':'Leo','age':33}
]
# type объекта
print(type(friends))
# преобразуем список друзей в json
json_friends = json.dumps(friends)
# печатаем что получилось 
print(json_friends)
# проверяем тип 
print(type(json_friends))
# обратно из json в объект
friends = json.loads(json_friends)
print(friends)
print(type(friends))

# открываем файл 
with open ('friends.jon','w') as f:
    # преобразуем список друзей в json и сохраняем в файл
    json_friends = json.dump(friends,f)
# обратно из файла в объект
with open('friends.jon','r') as f:
    friends = json.load(f)

print(friends)
print(type(friends))